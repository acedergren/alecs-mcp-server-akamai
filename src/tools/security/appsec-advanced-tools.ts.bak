/**
 * Akamai Application Security Advanced Tools
 * 
 * Advanced APPSEC tools for custom security rules, IP reputation management,
 * security analytics, attack pattern analysis, and advanced threat mitigation.
 * 
 * Features:
 * - Custom security rule creation and management
 * - IP reputation and geolocation controls
 * - Advanced security analytics and reporting
 * - Attack pattern analysis and machine learning insights
 * - Adaptive security policies
 * - Security workflow automation
 * - Compliance and audit reporting
 * - Advanced threat hunting capabilities
 */

import { z } from 'zod';
import { 
  createEdgeGridAuth, 
  EdgeGridConfig, 
  validateCustomerExists,
  getCustomerConfig 
} from '../../utils/edgegrid-auth.js';
import { PerformanceMonitor } from '../../utils/performance-monitor.js';
import { ResilienceManager } from '../../utils/resilience-manager.js';
import { formatJson, formatTable, formatList } from '../../utils/formatting.js';

const performanceMonitor = PerformanceMonitor.getInstance();
const resilienceManager = ResilienceManager.getInstance();

// Base schemas
const CustomerSchema = z.object({
  customer: z.string().optional().describe('Customer section name from .edgerc (default: "default")')
});

// Custom Rule schemas
const CustomRuleSchema = z.object({
  ...CustomerSchema.shape,
  configId: z.number().describe('Application Security configuration ID'),
  ruleName: z.string().describe('Name for the custom rule'),
  description: z.string().optional().describe('Rule description'),
  conditions: z.array(z.object({
    type: z.enum(['requestHeader', 'requestMethod', 'path', 'query', 'requestBody', 'args', 'files']),
    positiveMatch: z.boolean().describe('True for positive match, false for negative'),
    header: z.string().optional().describe('Header name (for requestHeader type)'),
    value: z.string().describe('Value to match'),
    valueCase: z.boolean().optional().describe('Case sensitive matching'),
    valueWildcard: z.boolean().optional().describe('Wildcard matching'),
    valueBase64: z.boolean().optional().describe('Base64 decode before matching')
  })).describe('Conditions that trigger the rule'),
  tag: z.array(z.string()).optional().describe('Tags for rule categorization'),
  structured: z.boolean().optional().describe('Use structured rule format'),
  version: z.number().optional().describe('Rule version')
});

// IP Reputation schemas
const IPReputationSchema = z.object({
  ...CustomerSchema.shape,
  configId: z.number().describe('Application Security configuration ID'),
  policyId: z.string().describe('Security policy ID'),
  action: z.enum(['alert', 'deny', 'none']).describe('Action for IP reputation matches'),
  enableAnonymousProxies: z.boolean().optional().describe('Block anonymous proxies'),
  enableTorExitNodes: z.boolean().optional().describe('Block Tor exit nodes'),
  enableMaliciousIPs: z.boolean().optional().describe('Block known malicious IPs'),
  enableBotnetIPs: z.boolean().optional().describe('Block botnet IPs'),
  enableScanningIPs: z.boolean().optional().describe('Block scanning/reconnaissance IPs'),
  threshold: z.enum(['low', 'medium', 'high']).optional().describe('Reputation threshold')
});

// Geolocation Control schemas
const GeolocationControlSchema = z.object({
  ...CustomerSchema.shape,
  configId: z.number().describe('Application Security configuration ID'),
  policyId: z.string().describe('Security policy ID'),
  action: z.enum(['alert', 'deny', 'none']).describe('Action for geo-blocked requests'),
  blockMode: z.enum(['allow', 'block']).describe('Block or allow mode'),
  countries: z.array(z.string()).describe('Country codes (ISO 3166-1 alpha-2)'),
  continents: z.array(z.string()).optional().describe('Continent codes'),
  regions: z.array(z.string()).optional().describe('Region codes'),
  asns: z.array(z.number()).optional().describe('ASN numbers to block/allow'),
  unknownHandling: z.enum(['allow', 'block']).optional().describe('How to handle unknown locations')
});

// Security Analytics schemas
const SecurityAnalyticsSchema = z.object({
  ...CustomerSchema.shape,
  configId: z.number().describe('Application Security configuration ID'),
  from: z.string().describe('Start time (ISO 8601 format)'),
  to: z.string().describe('End time (ISO 8601 format)'),
  reportType: z.enum(['attacks', 'topCountries', 'topIPs', 'topRules', 'topAttackGroups', 'trends']).describe('Type of analytics report'),
  dimension: z.enum(['time', 'country', 'ip', 'rule', 'attackGroup', 'hostname']).optional().describe('Report dimension'),
  limit: z.number().max(1000).optional().describe('Maximum number of results'),
  includeEmpty: z.boolean().optional().describe('Include periods with zero events')
});

// Attack Pattern Analysis schemas
const AttackPatternAnalysisSchema = z.object({
  ...CustomerSchema.shape,
  configId: z.number().describe('Application Security configuration ID'),
  analysisType: z.enum(['pattern', 'anomaly', 'trend', 'correlation']).describe('Type of analysis to perform'),
  timeWindow: z.enum(['1h', '6h', '24h', '7d', '30d']).describe('Time window for analysis'),
  threshold: z.number().optional().describe('Threshold for anomaly detection'),
  includeMLInsights: z.boolean().optional().describe('Include machine learning insights'),
  attackTypes: z.array(z.string()).optional().describe('Specific attack types to analyze'),
  sourceFilters: z.object({
    countries: z.array(z.string()).optional(),
    ips: z.array(z.string()).optional(),
    asns: z.array(z.number()).optional()
  }).optional().describe('Source filtering options')
});

// Adaptive Security Policy schemas
const AdaptiveSecurityPolicySchema = z.object({
  ...CustomerSchema.shape,
  configId: z.number().describe('Application Security configuration ID'),
  policyId: z.string().describe('Security policy ID'),
  enableAdaptiveSecurity: z.boolean().describe('Enable adaptive security features'),
  learningMode: z.enum(['passive', 'active', 'aggressive']).describe('Learning mode for adaptive policies'),
  adaptationThreshold: z.number().min(1).max(10).optional().describe('Sensitivity threshold (1-10)'),
  autoBlockEnabled: z.boolean().optional().describe('Enable automatic blocking of detected threats'),
  whitelistLearning: z.boolean().optional().describe('Learn and create whitelists automatically'),
  falsePositiveReduction: z.boolean().optional().describe('Enable false positive reduction'),
  maxAdaptationsPerHour: z.number().optional().describe('Maximum policy adaptations per hour')
});

// Security Workflow schemas
const SecurityWorkflowSchema = z.object({
  ...CustomerSchema.shape,
  workflowName: z.string().describe('Name for the security workflow'),
  description: z.string().optional().describe('Workflow description'),
  triggers: z.array(z.object({
    type: z.enum(['threshold', 'pattern', 'anomaly', 'time']),
    condition: z.string(),
    value: z.union([z.string(), z.number()])
  })).describe('Workflow triggers'),
  actions: z.array(z.object({
    type: z.enum(['notify', 'block', 'rate_limit', 'challenge', 'log']),
    parameters: z.record(z.any())
  })).describe('Actions to execute'),
  enabled: z.boolean().optional().describe('Enable the workflow'),
  priority: z.enum(['low', 'medium', 'high', 'critical']).optional().describe('Workflow priority')
});

/**
 * Create custom security rule
 */
export const create_custom_security_rule = {
  name: 'create_custom_security_rule',
  description: 'Create a custom security rule with advanced conditions and logic',
  parameters: CustomRuleSchema,
  handler: async (args: z.infer<typeof CustomRuleSchema>) => {
    const customer = args.customer || 'default';
    
    return await resilienceManager.executeWithResilience(
      'APPSEC_WRITE',
      async () => {
        await validateCustomerExists(customer);
        const config = getCustomerConfig(customer);
        const auth = createEdgeGridAuth(config);
        
        const ruleData = {
          name: args.ruleName,
          ...(args.description && { description: args.description }),
          conditions: args.conditions,
          ...(args.tag && { tag: args.tag }),
          ...(args.structured !== undefined && { structured: args.structured }),
          ...(args.version && { version: args.version })
        };
        
        const response = await auth.post(
          `/appsec/v1/configs/${args.configId}/versions/1/custom-rules`,
          { body: JSON.stringify(ruleData) }
        );
        
        if (!response.ok) {
          throw new Error(`Failed to create custom security rule: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        return {
          success: true,
          data: {
            rule: data,
            ruleId: data.id,
            message: `Custom security rule '${args.ruleName}' created successfully`,
            formatted: formatJson(data)
          }
        };
      },
      customer
    );
  }
};

/**
 * Configure IP reputation controls
 */
export const configure_ip_reputation = {
  name: 'configure_ip_reputation',
  description: 'Configure IP reputation-based blocking and controls',
  parameters: IPReputationSchema,
  handler: async (args: z.infer<typeof IPReputationSchema>) => {
    const customer = args.customer || 'default';
    
    return await resilienceManager.executeWithResilience(
      'APPSEC_WRITE',
      async () => {
        await validateCustomerExists(customer);
        const config = getCustomerConfig(customer);
        const auth = createEdgeGridAuth(config);
        
        const reputationData = {
          action: args.action,
          ...(args.enableAnonymousProxies !== undefined && { enableAnonymousProxies: args.enableAnonymousProxies }),
          ...(args.enableTorExitNodes !== undefined && { enableTorExitNodes: args.enableTorExitNodes }),
          ...(args.enableMaliciousIPs !== undefined && { enableMaliciousIPs: args.enableMaliciousIPs }),
          ...(args.enableBotnetIPs !== undefined && { enableBotnetIPs: args.enableBotnetIPs }),
          ...(args.enableScanningIPs !== undefined && { enableScanningIPs: args.enableScanningIPs }),
          ...(args.threshold && { threshold: args.threshold })
        };
        
        const response = await auth.put(
          `/appsec/v1/configs/${args.configId}/versions/1/security-policies/${args.policyId}/ip-geo`,
          { body: JSON.stringify(reputationData) }
        );
        
        if (!response.ok) {
          throw new Error(`Failed to configure IP reputation: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        return {
          success: true,
          data: {
            ipReputation: data,
            message: `IP reputation controls configured with action: ${args.action}`,
            formatted: formatJson(data)
          }
        };
      },
      customer
    );
  }
};

/**
 * Configure geolocation controls
 */
export const configure_geolocation_controls = {
  name: 'configure_geolocation_controls',
  description: 'Configure geolocation-based access controls and blocking',
  parameters: GeolocationControlSchema,
  handler: async (args: z.infer<typeof GeolocationControlSchema>) => {
    const customer = args.customer || 'default';
    
    return await resilienceManager.executeWithResilience(
      'APPSEC_WRITE',
      async () => {
        await validateCustomerExists(customer);
        const config = getCustomerConfig(customer);
        const auth = createEdgeGridAuth(config);
        
        const geoData = {
          action: args.action,
          blockMode: args.blockMode,
          countries: args.countries,
          ...(args.continents && { continents: args.continents }),
          ...(args.regions && { regions: args.regions }),
          ...(args.asns && { asns: args.asns }),
          ...(args.unknownHandling && { unknownHandling: args.unknownHandling })
        };
        
        const response = await auth.put(
          `/appsec/v1/configs/${args.configId}/versions/1/security-policies/${args.policyId}/ip-geo-firewall`,
          { body: JSON.stringify(geoData) }
        );
        
        if (!response.ok) {
          throw new Error(`Failed to configure geolocation controls: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        return {
          success: true,
          data: {
            geolocation: data,
            message: `Geolocation controls configured for ${args.countries.length} countries`,
            formatted: formatJson(data)
          }
        };
      },
      customer
    );
  }
};

/**
 * Get security analytics report
 */
export const get_security_analytics = {
  name: 'get_security_analytics',
  description: 'Generate comprehensive security analytics and threat intelligence reports',
  parameters: SecurityAnalyticsSchema,
  handler: async (args: z.infer<typeof SecurityAnalyticsSchema>) => {
    const customer = args.customer || 'default';
    
    return await resilienceManager.executeWithResilience(
      'APPSEC_READ',
      async () => {
        await validateCustomerExists(customer);
        const config = getCustomerConfig(customer);
        const auth = createEdgeGridAuth(config);
        
        const queryParams = new URLSearchParams({
          from: args.from,
          to: args.to,
          reportType: args.reportType,
          ...(args.dimension && { dimension: args.dimension }),
          ...(args.limit && { limit: args.limit.toString() }),
          ...(args.includeEmpty !== undefined && { includeEmpty: args.includeEmpty.toString() })
        });
        
        const response = await auth.get(
          `/appsec/v1/configs/${args.configId}/security-analytics?${queryParams.toString()}`
        );
        
        if (!response.ok) {
          throw new Error(`Failed to get security analytics: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Format based on report type
        let formatted = '';
        switch (args.reportType) {
          case 'attacks':
            formatted = formatTable(data.data?.map((item: any) => ({
              'Time': new Date(item.time).toLocaleString(),
              'Attack Count': item.attackCount,
              'Blocked': item.blocked,
              'Allowed': item.allowed,
              'Top Attack Group': item.topAttackGroup
            })) || []);
            break;
          case 'topCountries':
            formatted = formatTable(data.data?.map((item: any) => ({
              'Country': item.country,
              'Country Code': item.countryCode,
              'Attack Count': item.attackCount,
              'Percentage': `${item.percentage}%`
            })) || []);
            break;
          case 'topIPs':
            formatted = formatTable(data.data?.map((item: any) => ({
              'IP Address': item.ipAddress,
              'Attack Count': item.attackCount,
              'Country': item.country,
              'ASN': item.asn,
              'Last Seen': new Date(item.lastSeen).toLocaleString()
            })) || []);
            break;
          default:
            formatted = formatJson(data);
        }
        
        return {
          success: true,
          data: {
            analytics: data,
            reportType: args.reportType,
            timeRange: { from: args.from, to: args.to },
            summary: data.summary,
            formatted
          }
        };
      },
      customer
    );
  }
};

/**
 * Analyze attack patterns with ML insights
 */
export const analyze_attack_patterns = {
  name: 'analyze_attack_patterns',
  description: 'Analyze attack patterns using machine learning and advanced threat detection',
  parameters: AttackPatternAnalysisSchema,
  handler: async (args: z.infer<typeof AttackPatternAnalysisSchema>) => {
    const customer = args.customer || 'default';
    
    return await resilienceManager.executeWithResilience(
      'APPSEC_READ',
      async () => {
        await validateCustomerExists(customer);
        const config = getCustomerConfig(customer);
        const auth = createEdgeGridAuth(config);
        
        const analysisData = {
          analysisType: args.analysisType,
          timeWindow: args.timeWindow,
          ...(args.threshold && { threshold: args.threshold }),
          ...(args.includeMLInsights !== undefined && { includeMLInsights: args.includeMLInsights }),
          ...(args.attackTypes && { attackTypes: args.attackTypes }),
          ...(args.sourceFilters && { sourceFilters: args.sourceFilters })
        };
        
        const response = await auth.post(
          `/appsec/v1/configs/${args.configId}/attack-pattern-analysis`,
          { body: JSON.stringify(analysisData) }
        );
        
        if (!response.ok) {
          throw new Error(`Failed to analyze attack patterns: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        return {
          success: true,
          data: {
            analysis: data,
            patterns: data.patterns || [],
            anomalies: data.anomalies || [],
            mlInsights: data.mlInsights || {},
            recommendations: data.recommendations || [],
            riskScore: data.riskScore,
            formatted: formatJson(data)
          }
        };
      },
      customer
    );
  }
};

/**
 * Configure adaptive security policy
 */
export const configure_adaptive_security = {
  name: 'configure_adaptive_security',
  description: 'Configure adaptive security policies that learn and adapt to threats automatically',
  parameters: AdaptiveSecurityPolicySchema,
  handler: async (args: z.infer<typeof AdaptiveSecurityPolicySchema>) => {
    const customer = args.customer || 'default';
    
    return await resilienceManager.executeWithResilience(
      'APPSEC_WRITE',
      async () => {
        await validateCustomerExists(customer);
        const config = getCustomerConfig(customer);
        const auth = createEdgeGridAuth(config);
        
        const adaptiveData = {
          enableAdaptiveSecurity: args.enableAdaptiveSecurity,
          learningMode: args.learningMode,
          ...(args.adaptationThreshold && { adaptationThreshold: args.adaptationThreshold }),
          ...(args.autoBlockEnabled !== undefined && { autoBlockEnabled: args.autoBlockEnabled }),
          ...(args.whitelistLearning !== undefined && { whitelistLearning: args.whitelistLearning }),
          ...(args.falsePositiveReduction !== undefined && { falsePositiveReduction: args.falsePositiveReduction }),
          ...(args.maxAdaptationsPerHour && { maxAdaptationsPerHour: args.maxAdaptationsPerHour })
        };
        
        const response = await auth.put(
          `/appsec/v1/configs/${args.configId}/versions/1/security-policies/${args.policyId}/adaptive-security`,
          { body: JSON.stringify(adaptiveData) }
        );
        
        if (!response.ok) {
          throw new Error(`Failed to configure adaptive security: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        return {
          success: true,
          data: {
            adaptiveSecurity: data,
            enabled: args.enableAdaptiveSecurity,
            learningMode: args.learningMode,
            message: `Adaptive security configured with ${args.learningMode} learning mode`,
            formatted: formatJson(data)
          }
        };
      },
      customer
    );
  }
};

/**
 * Create security workflow automation
 */
export const create_security_workflow = {
  name: 'create_security_workflow',
  description: 'Create automated security workflow for threat response and mitigation',
  parameters: SecurityWorkflowSchema,
  handler: async (args: z.infer<typeof SecurityWorkflowSchema>) => {
    const customer = args.customer || 'default';
    
    return await resilienceManager.executeWithResilience(
      'APPSEC_WRITE',
      async () => {
        await validateCustomerExists(customer);
        const config = getCustomerConfig(customer);
        const auth = createEdgeGridAuth(config);
        
        const workflowData = {
          name: args.workflowName,
          ...(args.description && { description: args.description }),
          triggers: args.triggers,
          actions: args.actions,
          ...(args.enabled !== undefined && { enabled: args.enabled }),
          ...(args.priority && { priority: args.priority })
        };
        
        const response = await auth.post(
          '/appsec/v1/security-workflows',
          { body: JSON.stringify(workflowData) }
        );
        
        if (!response.ok) {
          throw new Error(`Failed to create security workflow: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        return {
          success: true,
          data: {
            workflow: data,
            workflowId: data.id,
            message: `Security workflow '${args.workflowName}' created successfully`,
            formatted: formatJson(data)
          }
        };
      },
      customer
    );
  }
};

/**
 * Generate compliance report
 */
export const generate_compliance_report = {
  name: 'generate_compliance_report',
  description: 'Generate compliance and audit report for security configurations',
  parameters: z.object({
    ...CustomerSchema.shape,
    configId: z.number().describe('Application Security configuration ID'),
    reportType: z.enum(['PCI_DSS', 'SOX', 'GDPR', 'HIPAA', 'SOC2', 'comprehensive']).describe('Compliance framework'),
    from: z.string().describe('Start time (ISO 8601 format)'),
    to: z.string().describe('End time (ISO 8601 format)'),
    includeRecommendations: z.boolean().optional().describe('Include compliance recommendations'),
    includeRemediationPlan: z.boolean().optional().describe('Include remediation plan')
  }),
  handler: async (args: z.infer<typeof z.object({
    ...CustomerSchema.shape,
    configId: z.number(),
    reportType: z.enum(['PCI_DSS', 'SOX', 'GDPR', 'HIPAA', 'SOC2', 'comprehensive']),
    from: z.string(),
    to: z.string(),
    includeRecommendations: z.boolean().optional(),
    includeRemediationPlan: z.boolean().optional()
  })>) => {
    const customer = args.customer || 'default';
    
    return await resilienceManager.executeWithResilience(
      'APPSEC_READ',
      async () => {
        await validateCustomerExists(customer);
        const config = getCustomerConfig(customer);
        const auth = createEdgeGridAuth(config);
        
        const queryParams = new URLSearchParams({
          reportType: args.reportType,
          from: args.from,
          to: args.to,
          ...(args.includeRecommendations !== undefined && { 
            includeRecommendations: args.includeRecommendations.toString() 
          }),
          ...(args.includeRemediationPlan !== undefined && { 
            includeRemediationPlan: args.includeRemediationPlan.toString() 
          })
        });
        
        const response = await auth.get(
          `/appsec/v1/configs/${args.configId}/compliance-report?${queryParams.toString()}`
        );
        
        if (!response.ok) {
          throw new Error(`Failed to generate compliance report: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        return {
          success: true,
          data: {
            report: data,
            framework: args.reportType,
            timeRange: { from: args.from, to: args.to },
            complianceScore: data.complianceScore,
            findings: data.findings || [],
            recommendations: data.recommendations || [],
            remediationPlan: data.remediationPlan || {},
            formatted: formatJson(data)
          }
        };
      },
      customer
    );
  }
};

/**
 * Advanced threat hunting
 */
export const advanced_threat_hunting = {
  name: 'advanced_threat_hunting',
  description: 'Perform advanced threat hunting with behavioral analysis and IOC detection',
  parameters: z.object({
    ...CustomerSchema.shape,
    configId: z.number().describe('Application Security configuration ID'),
    huntingQuery: z.string().describe('Threat hunting query (supports KQL-like syntax)'),
    timeRange: z.enum(['1h', '6h', '24h', '7d', '30d']).describe('Time range for hunting'),
    enableBehavioralAnalysis: z.boolean().optional().describe('Enable behavioral analysis'),
    iocSources: z.array(z.string()).optional().describe('Threat intelligence IOC sources'),
    riskThreshold: z.enum(['low', 'medium', 'high', 'critical']).optional().describe('Risk threshold filter'),
    includeContext: z.boolean().optional().describe('Include attack context and attribution')
  }),
  handler: async (args: z.infer<typeof z.object({
    ...CustomerSchema.shape,
    configId: z.number(),
    huntingQuery: z.string(),
    timeRange: z.enum(['1h', '6h', '24h', '7d', '30d']),
    enableBehavioralAnalysis: z.boolean().optional(),
    iocSources: z.array(z.string()).optional(),
    riskThreshold: z.enum(['low', 'medium', 'high', 'critical']).optional(),
    includeContext: z.boolean().optional()
  })>) => {
    const customer = args.customer || 'default';
    
    return await resilienceManager.executeWithResilience(
      'APPSEC_READ',
      async () => {
        await validateCustomerExists(customer);
        const config = getCustomerConfig(customer);
        const auth = createEdgeGridAuth(config);
        
        const huntingData = {
          query: args.huntingQuery,
          timeRange: args.timeRange,
          ...(args.enableBehavioralAnalysis !== undefined && { 
            enableBehavioralAnalysis: args.enableBehavioralAnalysis 
          }),
          ...(args.iocSources && { iocSources: args.iocSources }),
          ...(args.riskThreshold && { riskThreshold: args.riskThreshold }),
          ...(args.includeContext !== undefined && { includeContext: args.includeContext })
        };
        
        const response = await auth.post(
          `/appsec/v1/configs/${args.configId}/threat-hunting`,
          { body: JSON.stringify(huntingData) }
        );
        
        if (!response.ok) {
          throw new Error(`Failed to execute threat hunting: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        return {
          success: true,
          data: {
            huntingResults: data,
            threats: data.threats || [],
            indicators: data.indicators || [],
            behavioralInsights: data.behavioralInsights || {},
            riskAssessment: data.riskAssessment || {},
            attribution: data.attribution || {},
            recommendations: data.recommendations || [],
            formatted: formatTable(data.threats?.map((threat: any) => ({
              'Threat ID': threat.id,
              'Risk Level': threat.riskLevel,
              'Source IP': threat.sourceIP,
              'Country': threat.country,
              'Attack Type': threat.attackType,
              'First Seen': new Date(threat.firstSeen).toLocaleString(),
              'Last Seen': new Date(threat.lastSeen).toLocaleString(),
              'IOCs': threat.iocs?.length || 0
            })) || [])
          }
        };
      },
      customer
    );
  }
};

// Export all advanced tools
export const appsecAdvancedTools = [
  create_custom_security_rule,
  configure_ip_reputation,
  configure_geolocation_controls,
  get_security_analytics,
  analyze_attack_patterns,
  configure_adaptive_security,
  create_security_workflow,
  generate_compliance_report,
  advanced_threat_hunting
];

export default appsecAdvancedTools;