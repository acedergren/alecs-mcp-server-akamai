import { z } from 'zod';import { AkamaiOperation, MCPToolResponse } from '../common';import {  isEdgeDNSZonesResponse,  isEdgeDNSZoneResponse,  EdgeDNSZonesResponse,  EdgeDNSZoneResponse,} from '../../types/api-responses/edge-dns-zones';const ListZonesSchema = z.object({  contractIds: z.array(z.string()).optional(),  includeAliases: z.boolean().optional(),  search: z.string().optional(),  sortBy: z.enum(['zone', 'type', 'lastModified']).optional(),  order: z.enum(['ASC', 'DESC']).optional(),  limit: z.number().optional(),  offset: z.number().optional(),});const GetZoneSchema = z.object({  zone: z.string(),});const CreateZoneSchema = z.object({  zone: z.string(),  type: z.enum(['PRIMARY', 'SECONDARY', 'ALIAS']),  comment: z.string().optional(),  contractId: z.string().optional(),  groupId: z.string().optional(),  masters: z.array(z.string()).optional(),  target: z.string().optional(),});type ListZonesArgs = z.infer<typeof ListZonesSchema>;type GetZoneArgs = z.infer<typeof GetZoneSchema>;type CreateZoneArgs = z.infer<typeof CreateZoneSchema>;async function listZones(  client: any,  args: ListZonesArgs): Promise<MCPToolResponse> {  return AkamaiOperation.execute(    'dns',    'list-zones',    args,    async (client) => {      const queryParams: Record<string, string> = {};      if (args.contractIds?.length) {        queryParams['contractIds'] = args.contractIds.join(',');      }      if (args.includeAliases !== undefined) {        queryParams['includeAliases'] = String(args.includeAliases);      }      if (args.search) {        queryParams['search'] = args.search;      }      if (args.sortBy) {        queryParams['sortBy'] = args.sortBy;      }      if (args.order) {        queryParams['order'] = args.order;      }      if (args.limit !== undefined) {        queryParams['limit'] = String(Math.min(args.limit, 1000));      }      if (args.offset !== undefined) {        queryParams['offset'] = String(args.offset);      }      const rawResponse = await client.request({        path: '/config-dns/v2/zones',        method: 'GET',        headers: {          'Content-Type': 'application/json',          Accept: 'application/json',        },        queryParams,      });      if (!isEdgeDNSZonesResponse(rawResponse)) {        throw new Error('Invalid Edge DNS zones response structure');      }      return rawResponse as EdgeDNSZonesResponse;    },    {      formatter: (response) => {        if (!response.zones || response.zones.length === 0) {          return 'No DNS zones found';        }        const zonesList = response.zones          .map(            (zone) =>              `${zone.zone} (${zone.type})${zone.comment ? ` - ${zone.comment}` : ''}`          )          .join('\n');        return `Found ${response.zones.length} DNS zones:\n\n${zonesList}`;      },    }  );}async function getZone(client: any, args: GetZoneArgs): Promise<MCPToolResponse> {  return AkamaiOperation.execute(    'dns',    'get-zone',    args,    async (client) => {      const rawResponse = await client.request({        path: `/config-dns/v2/zones/${args.zone}`,        method: 'GET',        headers: {          'Content-Type': 'application/json',          Accept: 'application/json',        },      });      if (!isEdgeDNSZoneResponse(rawResponse)) {        throw new Error('Invalid Edge DNS zone response structure');      }      return rawResponse as EdgeDNSZoneResponse;    },    {      formatter: (response) => {        let details = `DNS Zone: ${response.zone}\n`;        details += `Type: ${response.type}\n`;        if (response.comment) {          details += `Comment: ${response.comment}\n`;        }        if (response.signAndServe !== undefined) {          details += `DNSSEC: ${response.signAndServe ? 'Enabled' : 'Disabled'}\n`;        }        if (response.type === 'SECONDARY' && response.masters) {          details += `Master servers: ${response.masters.join(', ')}\n`;        }        return details;      },    }  );}async function createZone(  client: any,  args: CreateZoneArgs): Promise<MCPToolResponse> {  return AkamaiOperation.execute(    'dns',    'create-zone',    args,    async (client) => {      const body: Partial<EdgeDNSZoneResponse> = {        zone: args.zone,        type: args.type,        comment: args.comment || `Created via ALECS MCP server`,      };      if (args.type === 'SECONDARY') {        if (!args.masters || args.masters.length === 0) {          throw new Error('Masters required for SECONDARY zone');        }        body.masters = args.masters;      }      if (args.type === 'ALIAS') {        if (!args.target) {          throw new Error('Target required for ALIAS zone');        }        body.target = args.target;      }      const queryParams: Record<string, string> = {};      if (args.contractId) {        queryParams['contractId'] = args.contractId;      }      if (args.groupId) {        queryParams['gid'] = args.groupId;      }      await client.request({        path: '/config-dns/v2/zones',        method: 'POST',        headers: {          'Content-Type': 'application/json',          Accept: 'application/json',        },        body,        queryParams,      });      return { zone: args.zone, type: args.type };    },    {      formatter: (data) => {        return `Successfully created DNS zone: ${data.zone} (Type: ${data.type})`;      },    }  );}export const dnsZoneOperations = {  'list-zones': {    handler: listZones,    schema: ListZonesSchema,    description: 'List all DNS zones.',  },  'get-zone': {    handler: getZone,    schema: GetZoneSchema,    description: 'Get details for a specific DNS zone.',  },  'create-zone': {    handler: createZone,    schema: CreateZoneSchema,    description: 'Create a new DNS zone.',  },};